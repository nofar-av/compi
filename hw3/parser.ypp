%{
	#include "output.hpp"
	#include <iostream>
	#include <stdlib.h>
        #include "decl.hpp"
	typedef enum { OP_AND, OP_OR } opType;

	using namespace std;
        int yylex();
        extern int yylineno;
	void yyerror(const char * message);
        %union
        {
                byte b;
                int num;
                bool f;
                string s;
        }
%}

%token VOID
%token INT
%token BYTE
%token B
%token BOOL
%token OVERRIDE
%token TRUE
%token FALSE
%token RETURN
%token IF
%token WHILE
%token BREAK
%token CONTINUE
%token SC
%token COMMA
%token ID
%token NUM
%token STRING
%right ASSIGN
%left OR
%left AND
%left RELOP
%left BINOP_ADD
%left BINOP_MUL
%nonassoc NOT
%left LPAREN LBRACE RPAREN RBRACE
%nonassoc ELSE

%%
Program : Funcs { };

Funcs : /* epsilon */ { }
        | FuncDecl Funcs { };

FuncDecl : OverRide RetType ID LPAREN Formals RPAREN LBRACE AddScopeMarker Statements RBRACE { symtable.removeScope(); };

OverRide : /* epsilon */ { $$ = new OverRide(); }
        |  OVERRIDE { $$ = new OverRide(true); };

RetType : Type                          {$$ = new RetType(dynamic_cast<Type*>($1)->type);}
        | VOID                          {$$ = new RetType("void");};

Formals : /* epsilon */ { $$ = new Formals(); }
        | FormalsList { $$ = new Formals(dynamic_cast<FormalsList*>($1)); };

FormalsList : FormalDecl { $$ = new FormalsList(dynamic_cast<FormalDecl*>($1)); }
            | FormalDecl COMMA FormalsList { $$ = new FormalsList(dynamic_cast<FormalDecl*>($1), 
                                                        dynamic_cast<FormalsList*>($3)); };

FormalDecl : Type ID { $$ = new FormalDecl(dynamic_cast<Type*>($1), $2.value) };

Statements : Statement { output::printProductionRule(14); }
            | Statements Statement { output::printProductionRule(15); };

Statement : LBRACE AddScopeMarker Statements RBRACE { symtable.removeScope(); }
        | Type ID SC {  symtable.addSymbol($2.name, $1.type); 
                        output::printProductionRule(17); }
        | Type ID ASSIGN Exp SC { symtable.addSymbol($2.name, $1.type);
                                  output::printProductionRule(18); }
        | ID ASSIGN Exp SC { symtable.addSymbol($2.name, $3.type);
                             output::printProductionRule(19); }
        | Call SC { output::printProductionRule(20); }
        | RETURN SC { output::printProductionRule(21); }
        | RETURN Exp SC { output::printProductionRule(22); }
        | IF LPAREN Exp RPAREN AddScopeMarker Statement { symtable.removeScope(); }
        | IF LPAREN Exp RPAREN AddScopeMarker Statement removeScope ELSE AddScopeMarker Statement { symtable.removeScope(); }
        | WHILE LPAREN Exp RPAREN AddLoopScopeMarker Statement { symtable.removeScope(); }
        | BREAK SC { symtable.verifyInLoop(true); }
        | CONTINUE SC { symtable.verifyInLoop(false); }
        ;

Call : ID LPAREN ExpList RPAREN         {$$ = new Call($1, dynamic_cast<ExpList*>($3));}
    | ID LPAREN RPAREN                  {$$ = new Call($1);};

ExpList : Exp                   {$$ = new ExpList(dynamic_cast<Exp*>($1));}
        | Exp COMMA ExpList     {$$ = new ExpList(dynamic_cast<Exp*>($1), dynamic_cast<ExpList*>($3));};

Type : INT { $$ = new Type("int"); }
    | BYTE { $$ = new Type("byte"); }
    | BOOL { $$ = new Type("bool"); };

Exp : LPAREN Exp RPAREN                                            {$$ = new Exp(dynamic_cast<Exp*>($2));}
    | Exp BINOP_MUL Exp                                            {$$ = new Exp($1, $3, "int", $2->value);}
    | Exp BINOP_ADD Exp                                            {$$ = new Exp($1, $3, "int", $2->value);}
    | ID                                                           {$$ = new Exp($1);}
    | Call                                                         {$$ = new Exp(dynamic_cast<Call*>($1));}
    | NUM                                                          {$$ = new Exp($1, "int");}
    | NUM B                                                        {$$ = new Exp($1, "byte");}
    | STRING                                                       {$$ = new Exp($1, "string");}
    | TRUE                                                         {$$ = new Exp($1, "bool");}
    | FALSE                                                        {$$ = new Exp($1, "bool");}
    | NOT Exp                                                      {$$ = new Exp($2, "bool", $1->value);}
    | Exp AND Exp                                                  {$$ = new Exp($1, $3, "bool", $2->value);}
    | Exp OR Exp                                                   {$$ = new Exp($1, $3, "bool", $2->value);}
    | Exp RELOP Exp                                                {$$ = new Exp($1, $3, "bool", $2->value);}
    | LPAREN Type RPAREN Exp                                       {$$ = new Exp($4, $2);};

AddScopeMarker : /* epsilon */ {symtable.addScope(false);};
AddLoopScopeMarker : /* epsilon */ {symtable.addScope(true);};
RemoveScopeMarker : /* epsilon */ {symtable.removeScope();};
%%

SymTable symtable = new SymTable(); 
int main()
{
	return yyparse();
}

void yyerror(const char * message)
{
	output::errorSyn(yylineno);
        exit(0);
}